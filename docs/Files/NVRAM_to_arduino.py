from __future__ import print_function
from collections import OrderedDict
import argparse
import os
import re

# number whitespace number 
data_line = re.compile(r"^(\d+?)\s+(\d+?).*$")

def parse_file_to_bit_dict(filename):
	"""Parses a GreenPAK NVRAM file to a dict of bit locations"""
	data = OrderedDict()
	with open(filename, 'r') as f:
		for line in f:
			m = data_line.match(line)
			try:
				if int(m.group(2)) not in [0, 1]:
					continue

				data[int(m.group(1))] = int(m.group(2))
			except (AttributeError) as e:
				pass
	return data

def cleanup_bit_dict(input_dict):
	# sort bits
	input_dict = OrderedDict(sorted(input_dict.items(), key=lambda x: x[0]))
	add_dict = OrderedDict()
	last_key = -1
	for key, _ in input_dict.items():
		for i in range(last_key + 1, key):
			add_dict[i] = 0
		last_key = key
	input_dict.update(add_dict)
	return input_dict

def bits_to_bytes(input_dict):
	input_dict = OrderedDict(sorted(input_dict.items(), key=lambda x: x[0]))
	out = list()
	temp = ""

	for _, value in input_dict.items():
		if len(temp) == 8:
			out.append(int(temp, 2))
			temp = ""
		temp = "{}{}".format(temp, value)
	return out

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='Program to convert GreenPAK NVRAM/EEPROM files to byte arrays for arduino use')
	parser.add_argument('input_file', action='store', type=str)
	args = parser.parse_args()

	data = parse_file_to_bit_dict(args.input_file)
	data = cleanup_bit_dict(data)
	data = bits_to_bytes(data)

	output_path = os.path.splitext(args.input_file)[0] + '.h'

	with open(output_path, 'w') as f:
		f.write("//Auto generated by NVRAM_to_arduino.py\n")
		f.write("\n\n")
		f.write("byte config_data[] = {};\n\n".format(str(data).replace('[', '{').replace(']','}')))

	print("Output at {}".format(output_path))
